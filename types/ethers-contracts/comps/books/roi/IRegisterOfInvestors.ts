/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../../../common.js"
  
export declare namespace InvestorsRepo {
      
    export type InvestorStruct = {userNo: BigNumberish, groupRep: BigNumberish, regDate: BigNumberish, verifier: BigNumberish, approveDate: BigNumberish, data: BigNumberish, state: BigNumberish, idHash: BytesLike}

    export type InvestorStructOutput = [userNo: bigint, groupRep: bigint, regDate: bigint, verifier: bigint, approveDate: bigint, data: bigint, state: bigint, idHash: string] & {userNo: bigint, groupRep: bigint, regDate: bigint, verifier: bigint, approveDate: bigint, data: bigint, state: bigint, idHash: string }
  
    }

  export interface IRegisterOfInvestorsInterface extends Interface {
    getFunction(nameOrSignature: "approveInvestor" | "forceTransfer" | "freezeShare" | "frozenPaid" | "frozenShares" | "getInvestor" | "getQtyOfInvestors" | "investorInfoList" | "investorList" | "isFrozen" | "isFrozenShare" | "isInvestor" | "isPaused" | "pause" | "regInvestor" | "restoreInvestorsRepo" | "revokeInvestor" | "unPause" | "unfreezeShare"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "ApproveInvestor" | "ForceTransfer" | "FreezeShare" | "Paused" | "RegInvestor" | "RevokeInvestor" | "UnPaused" | "UnfreezeShare"): EventFragment;

    encodeFunctionData(functionFragment: 'approveInvestor', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'forceTransfer', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BytesLike]): string;
encodeFunctionData(functionFragment: 'freezeShare', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BytesLike]): string;
encodeFunctionData(functionFragment: 'frozenPaid', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'frozenShares', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getInvestor', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'getQtyOfInvestors', values?: undefined): string;
encodeFunctionData(functionFragment: 'investorInfoList', values?: undefined): string;
encodeFunctionData(functionFragment: 'investorList', values?: undefined): string;
encodeFunctionData(functionFragment: 'isFrozen', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'isFrozenShare', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'isInvestor', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'isPaused', values?: undefined): string;
encodeFunctionData(functionFragment: 'pause', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'regInvestor', values: [BigNumberish, BigNumberish, BytesLike]): string;
encodeFunctionData(functionFragment: 'restoreInvestorsRepo', values: [InvestorsRepo.InvestorStruct[], BigNumberish]): string;
encodeFunctionData(functionFragment: 'revokeInvestor', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'unPause', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'unfreezeShare', values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BytesLike]): string;

    decodeFunctionResult(functionFragment: 'approveInvestor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'forceTransfer', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'freezeShare', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'frozenPaid', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'frozenShares', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getInvestor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getQtyOfInvestors', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'investorInfoList', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'investorList', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isFrozen', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isFrozenShare', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isInvestor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isPaused', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'regInvestor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'restoreInvestorsRepo', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'revokeInvestor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'unPause', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'unfreezeShare', data: BytesLike): Result;
  }

  
    export namespace ApproveInvestorEvent {
      export type InputTuple = [investor: BigNumberish, verifier: BigNumberish];
      export type OutputTuple = [investor: bigint, verifier: bigint];
      export interface OutputObject {investor: bigint, verifier: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ForceTransferEvent {
      export type InputTuple = [seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike];
      export type OutputTuple = [seqOfShare: bigint, paid: bigint, caller: bigint, hashOrder: string];
      export interface OutputObject {seqOfShare: bigint, paid: bigint, caller: bigint, hashOrder: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace FreezeShareEvent {
      export type InputTuple = [seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike];
      export type OutputTuple = [seqOfShare: bigint, paid: bigint, caller: bigint, hashOrder: string];
      export interface OutputObject {seqOfShare: bigint, paid: bigint, caller: bigint, hashOrder: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace PausedEvent {
      export type InputTuple = [agent: BigNumberish];
      export type OutputTuple = [agent: bigint];
      export interface OutputObject {agent: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace RegInvestorEvent {
      export type InputTuple = [investor: BigNumberish, groupRep: BigNumberish, idHash: BytesLike];
      export type OutputTuple = [investor: bigint, groupRep: bigint, idHash: string];
      export interface OutputObject {investor: bigint, groupRep: bigint, idHash: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace RevokeInvestorEvent {
      export type InputTuple = [investor: BigNumberish, verifier: BigNumberish];
      export type OutputTuple = [investor: bigint, verifier: bigint];
      export interface OutputObject {investor: bigint, verifier: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace UnPausedEvent {
      export type InputTuple = [agent: BigNumberish];
      export type OutputTuple = [agent: bigint];
      export interface OutputObject {agent: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace UnfreezeShareEvent {
      export type InputTuple = [seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike];
      export type OutputTuple = [seqOfShare: bigint, paid: bigint, caller: bigint, hashOrder: string];
      export interface OutputObject {seqOfShare: bigint, paid: bigint, caller: bigint, hashOrder: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface IRegisterOfInvestors extends BaseContract {
    
    connect(runner?: ContractRunner | null): IRegisterOfInvestors;
    waitForDeployment(): Promise<this>;

    interface: IRegisterOfInvestorsInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    approveInvestor: TypedContractMethod<
      [userNo: BigNumberish, verifier: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    forceTransfer: TypedContractMethod<
      [userNo: BigNumberish, seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    freezeShare: TypedContractMethod<
      [userNo: BigNumberish, seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    frozenPaid: TypedContractMethod<
      [seqOfShare: BigNumberish, ],
      [bigint],
      'view'
    >
    

    
    frozenShares: TypedContractMethod<
      [userNo: BigNumberish, ],
      [bigint[]],
      'view'
    >
    

    
    getInvestor: TypedContractMethod<
      [userNo: BigNumberish, ],
      [InvestorsRepo.InvestorStructOutput],
      'view'
    >
    

    
    getQtyOfInvestors: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    investorInfoList: TypedContractMethod<
      [],
      [InvestorsRepo.InvestorStructOutput[]],
      'view'
    >
    

    
    investorList: TypedContractMethod<
      [],
      [bigint[]],
      'view'
    >
    

    
    isFrozen: TypedContractMethod<
      [userNo: BigNumberish, ],
      [boolean],
      'view'
    >
    

    
    isFrozenShare: TypedContractMethod<
      [seqOfShare: BigNumberish, ],
      [boolean],
      'view'
    >
    

    
    isInvestor: TypedContractMethod<
      [userNo: BigNumberish, ],
      [boolean],
      'view'
    >
    

    
    isPaused: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    pause: TypedContractMethod<
      [caller: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    regInvestor: TypedContractMethod<
      [userNo: BigNumberish, groupRep: BigNumberish, idHash: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    restoreInvestorsRepo: TypedContractMethod<
      [list: InvestorsRepo.InvestorStruct[], qtyOfInvestors: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    revokeInvestor: TypedContractMethod<
      [userNo: BigNumberish, verifier: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    unPause: TypedContractMethod<
      [caller: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    unfreezeShare: TypedContractMethod<
      [userNo: BigNumberish, seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike, ],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'approveInvestor'): TypedContractMethod<
      [userNo: BigNumberish, verifier: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'forceTransfer'): TypedContractMethod<
      [userNo: BigNumberish, seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'freezeShare'): TypedContractMethod<
      [userNo: BigNumberish, seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'frozenPaid'): TypedContractMethod<
      [seqOfShare: BigNumberish, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'frozenShares'): TypedContractMethod<
      [userNo: BigNumberish, ],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'getInvestor'): TypedContractMethod<
      [userNo: BigNumberish, ],
      [InvestorsRepo.InvestorStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'getQtyOfInvestors'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'investorInfoList'): TypedContractMethod<
      [],
      [InvestorsRepo.InvestorStructOutput[]],
      'view'
    >;
getFunction(nameOrSignature: 'investorList'): TypedContractMethod<
      [],
      [bigint[]],
      'view'
    >;
getFunction(nameOrSignature: 'isFrozen'): TypedContractMethod<
      [userNo: BigNumberish, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'isFrozenShare'): TypedContractMethod<
      [seqOfShare: BigNumberish, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'isInvestor'): TypedContractMethod<
      [userNo: BigNumberish, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'isPaused'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'pause'): TypedContractMethod<
      [caller: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'regInvestor'): TypedContractMethod<
      [userNo: BigNumberish, groupRep: BigNumberish, idHash: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'restoreInvestorsRepo'): TypedContractMethod<
      [list: InvestorsRepo.InvestorStruct[], qtyOfInvestors: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'revokeInvestor'): TypedContractMethod<
      [userNo: BigNumberish, verifier: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'unPause'): TypedContractMethod<
      [caller: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'unfreezeShare'): TypedContractMethod<
      [userNo: BigNumberish, seqOfShare: BigNumberish, paid: BigNumberish, caller: BigNumberish, hashOrder: BytesLike, ],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'ApproveInvestor'): TypedContractEvent<ApproveInvestorEvent.InputTuple, ApproveInvestorEvent.OutputTuple, ApproveInvestorEvent.OutputObject>;
getEvent(key: 'ForceTransfer'): TypedContractEvent<ForceTransferEvent.InputTuple, ForceTransferEvent.OutputTuple, ForceTransferEvent.OutputObject>;
getEvent(key: 'FreezeShare'): TypedContractEvent<FreezeShareEvent.InputTuple, FreezeShareEvent.OutputTuple, FreezeShareEvent.OutputObject>;
getEvent(key: 'Paused'): TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
getEvent(key: 'RegInvestor'): TypedContractEvent<RegInvestorEvent.InputTuple, RegInvestorEvent.OutputTuple, RegInvestorEvent.OutputObject>;
getEvent(key: 'RevokeInvestor'): TypedContractEvent<RevokeInvestorEvent.InputTuple, RevokeInvestorEvent.OutputTuple, RevokeInvestorEvent.OutputObject>;
getEvent(key: 'UnPaused'): TypedContractEvent<UnPausedEvent.InputTuple, UnPausedEvent.OutputTuple, UnPausedEvent.OutputObject>;
getEvent(key: 'UnfreezeShare'): TypedContractEvent<UnfreezeShareEvent.InputTuple, UnfreezeShareEvent.OutputTuple, UnfreezeShareEvent.OutputObject>;

    filters: {
      
      'ApproveInvestor(uint256,uint256)': TypedContractEvent<ApproveInvestorEvent.InputTuple, ApproveInvestorEvent.OutputTuple, ApproveInvestorEvent.OutputObject>;
      ApproveInvestor: TypedContractEvent<ApproveInvestorEvent.InputTuple, ApproveInvestorEvent.OutputTuple, ApproveInvestorEvent.OutputObject>;
    

      'ForceTransfer(uint256,uint256,uint256,bytes32)': TypedContractEvent<ForceTransferEvent.InputTuple, ForceTransferEvent.OutputTuple, ForceTransferEvent.OutputObject>;
      ForceTransfer: TypedContractEvent<ForceTransferEvent.InputTuple, ForceTransferEvent.OutputTuple, ForceTransferEvent.OutputObject>;
    

      'FreezeShare(uint256,uint256,uint256,bytes32)': TypedContractEvent<FreezeShareEvent.InputTuple, FreezeShareEvent.OutputTuple, FreezeShareEvent.OutputObject>;
      FreezeShare: TypedContractEvent<FreezeShareEvent.InputTuple, FreezeShareEvent.OutputTuple, FreezeShareEvent.OutputObject>;
    

      'Paused(uint256)': TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
      Paused: TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
    

      'RegInvestor(uint256,uint256,bytes32)': TypedContractEvent<RegInvestorEvent.InputTuple, RegInvestorEvent.OutputTuple, RegInvestorEvent.OutputObject>;
      RegInvestor: TypedContractEvent<RegInvestorEvent.InputTuple, RegInvestorEvent.OutputTuple, RegInvestorEvent.OutputObject>;
    

      'RevokeInvestor(uint256,uint256)': TypedContractEvent<RevokeInvestorEvent.InputTuple, RevokeInvestorEvent.OutputTuple, RevokeInvestorEvent.OutputObject>;
      RevokeInvestor: TypedContractEvent<RevokeInvestorEvent.InputTuple, RevokeInvestorEvent.OutputTuple, RevokeInvestorEvent.OutputObject>;
    

      'UnPaused(uint256)': TypedContractEvent<UnPausedEvent.InputTuple, UnPausedEvent.OutputTuple, UnPausedEvent.OutputObject>;
      UnPaused: TypedContractEvent<UnPausedEvent.InputTuple, UnPausedEvent.OutputTuple, UnPausedEvent.OutputObject>;
    

      'UnfreezeShare(uint256,uint256,uint256,bytes32)': TypedContractEvent<UnfreezeShareEvent.InputTuple, UnfreezeShareEvent.OutputTuple, UnfreezeShareEvent.OutputObject>;
      UnfreezeShare: TypedContractEvent<UnfreezeShareEvent.InputTuple, UnfreezeShareEvent.OutputTuple, UnfreezeShareEvent.OutputObject>;
    
    };
  }