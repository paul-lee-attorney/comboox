/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedListener, TypedContractMethod } from "../common.js"
  
export declare namespace RulesParser {
      
    export type DistrRuleStruct = {typeOfDistr: BigNumberish, numOfTiers: BigNumberish, isCumulative: boolean, refundPrincipal: boolean, tiers: BigNumberish[], rates: BigNumberish[]}

    export type DistrRuleStructOutput = [typeOfDistr: bigint, numOfTiers: bigint, isCumulative: boolean, refundPrincipal: boolean, tiers: bigint[], rates: bigint[]] & {typeOfDistr: bigint, numOfTiers: bigint, isCumulative: boolean, refundPrincipal: boolean, tiers: bigint[], rates: bigint[] }
  

    export type FirstRefusalRuleStruct = {seqOfRule: BigNumberish, qtyOfSubRule: BigNumberish, seqOfSubRule: BigNumberish, typeOfDeal: BigNumberish, membersEqual: boolean, proRata: boolean, basedOnPar: boolean, rightholders: [BigNumberish, BigNumberish, BigNumberish, BigNumberish], para: BigNumberish, argu: BigNumberish}

    export type FirstRefusalRuleStructOutput = [seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, typeOfDeal: bigint, membersEqual: boolean, proRata: boolean, basedOnPar: boolean, rightholders: [bigint, bigint, bigint, bigint], para: bigint, argu: bigint] & {seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, typeOfDeal: bigint, membersEqual: boolean, proRata: boolean, basedOnPar: boolean, rightholders: [bigint, bigint, bigint, bigint], para: bigint, argu: bigint }
  

    export type GovernanceRuleStruct = {fundApprovalThreshold: BigNumberish, basedOnPar: boolean, proposeWeightRatioOfGM: BigNumberish, proposeHeadRatioOfMembers: BigNumberish, proposeHeadRatioOfDirectorsInGM: BigNumberish, proposeHeadRatioOfDirectorsInBoard: BigNumberish, maxQtyOfMembers: BigNumberish, quorumOfGM: BigNumberish, maxNumOfDirectors: BigNumberish, tenureMonOfBoard: BigNumberish, quorumOfBoardMeeting: BigNumberish, establishedDate: BigNumberish, businessTermInYears: BigNumberish, typeOfComp: BigNumberish, minVoteRatioOnChain: BigNumberish}

    export type GovernanceRuleStructOutput = [fundApprovalThreshold: bigint, basedOnPar: boolean, proposeWeightRatioOfGM: bigint, proposeHeadRatioOfMembers: bigint, proposeHeadRatioOfDirectorsInGM: bigint, proposeHeadRatioOfDirectorsInBoard: bigint, maxQtyOfMembers: bigint, quorumOfGM: bigint, maxNumOfDirectors: bigint, tenureMonOfBoard: bigint, quorumOfBoardMeeting: bigint, establishedDate: bigint, businessTermInYears: bigint, typeOfComp: bigint, minVoteRatioOnChain: bigint] & {fundApprovalThreshold: bigint, basedOnPar: boolean, proposeWeightRatioOfGM: bigint, proposeHeadRatioOfMembers: bigint, proposeHeadRatioOfDirectorsInGM: bigint, proposeHeadRatioOfDirectorsInBoard: bigint, maxQtyOfMembers: bigint, quorumOfGM: bigint, maxNumOfDirectors: bigint, tenureMonOfBoard: bigint, quorumOfBoardMeeting: bigint, establishedDate: bigint, businessTermInYears: bigint, typeOfComp: bigint, minVoteRatioOnChain: bigint }
  

    export type GroupUpdateOrderStruct = {seqOfRule: BigNumberish, qtyOfSubRule: BigNumberish, seqOfSubRule: BigNumberish, addMember: boolean, groupRep: BigNumberish, members: [BigNumberish, BigNumberish, BigNumberish, BigNumberish], para: BigNumberish}

    export type GroupUpdateOrderStructOutput = [seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, addMember: boolean, groupRep: bigint, members: [bigint, bigint, bigint, bigint], para: bigint] & {seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, addMember: boolean, groupRep: bigint, members: [bigint, bigint, bigint, bigint], para: bigint }
  

    export type LinkRuleStruct = {triggerDate: BigNumberish, effectiveDays: BigNumberish, triggerType: BigNumberish, shareRatioThreshold: BigNumberish, rate: BigNumberish, proRata: boolean, seq: BigNumberish, para: BigNumberish, argu: BigNumberish, ref: BigNumberish, data: BigNumberish}

    export type LinkRuleStructOutput = [triggerDate: bigint, effectiveDays: bigint, triggerType: bigint, shareRatioThreshold: bigint, rate: bigint, proRata: boolean, seq: bigint, para: bigint, argu: bigint, ref: bigint, data: bigint] & {triggerDate: bigint, effectiveDays: bigint, triggerType: bigint, shareRatioThreshold: bigint, rate: bigint, proRata: boolean, seq: bigint, para: bigint, argu: bigint, ref: bigint, data: bigint }
  

    export type ListingRuleStruct = {seqOfRule: BigNumberish, titleOfIssuer: BigNumberish, classOfShare: BigNumberish, maxTotalPar: BigNumberish, titleOfVerifier: BigNumberish, maxQtyOfInvestors: BigNumberish, ceilingPrice: BigNumberish, floorPrice: BigNumberish, lockupDays: BigNumberish, offPrice: BigNumberish, votingWeight: BigNumberish, distrWeight: BigNumberish, para: BigNumberish}

    export type ListingRuleStructOutput = [seqOfRule: bigint, titleOfIssuer: bigint, classOfShare: bigint, maxTotalPar: bigint, titleOfVerifier: bigint, maxQtyOfInvestors: bigint, ceilingPrice: bigint, floorPrice: bigint, lockupDays: bigint, offPrice: bigint, votingWeight: bigint, distrWeight: bigint, para: bigint] & {seqOfRule: bigint, titleOfIssuer: bigint, classOfShare: bigint, maxTotalPar: bigint, titleOfVerifier: bigint, maxQtyOfInvestors: bigint, ceilingPrice: bigint, floorPrice: bigint, lockupDays: bigint, offPrice: bigint, votingWeight: bigint, distrWeight: bigint, para: bigint }
  

    export type PositionAllocateRuleStruct = {seqOfRule: BigNumberish, qtyOfSubRule: BigNumberish, seqOfSubRule: BigNumberish, removePos: boolean, seqOfPos: BigNumberish, titleOfPos: BigNumberish, nominator: BigNumberish, titleOfNominator: BigNumberish, seqOfVR: BigNumberish, endDate: BigNumberish, para: BigNumberish, argu: BigNumberish, data: BigNumberish}

    export type PositionAllocateRuleStructOutput = [seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, removePos: boolean, seqOfPos: bigint, titleOfPos: bigint, nominator: bigint, titleOfNominator: bigint, seqOfVR: bigint, endDate: bigint, para: bigint, argu: bigint, data: bigint] & {seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, removePos: boolean, seqOfPos: bigint, titleOfPos: bigint, nominator: bigint, titleOfNominator: bigint, seqOfVR: bigint, endDate: bigint, para: bigint, argu: bigint, data: bigint }
  

    export type VotingRuleStruct = {seqOfRule: BigNumberish, qtyOfSubRule: BigNumberish, seqOfSubRule: BigNumberish, authority: BigNumberish, headRatio: BigNumberish, amountRatio: BigNumberish, onlyAttendance: boolean, impliedConsent: boolean, partyAsConsent: boolean, againstShallBuy: boolean, frExecDays: BigNumberish, dtExecDays: BigNumberish, dtConfirmDays: BigNumberish, invExitDays: BigNumberish, votePrepareDays: BigNumberish, votingDays: BigNumberish, execDaysForPutOpt: BigNumberish, vetoers: [BigNumberish, BigNumberish], class: BigNumberish}

    export type VotingRuleStructOutput = [seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, authority: bigint, headRatio: bigint, amountRatio: bigint, onlyAttendance: boolean, impliedConsent: boolean, partyAsConsent: boolean, againstShallBuy: boolean, frExecDays: bigint, dtExecDays: bigint, dtConfirmDays: bigint, invExitDays: bigint, votePrepareDays: bigint, votingDays: bigint, execDaysForPutOpt: bigint, vetoers: [bigint, bigint], class_: bigint] & {seqOfRule: bigint, qtyOfSubRule: bigint, seqOfSubRule: bigint, authority: bigint, headRatio: bigint, amountRatio: bigint, onlyAttendance: boolean, impliedConsent: boolean, partyAsConsent: boolean, againstShallBuy: boolean, frExecDays: bigint, dtExecDays: bigint, dtConfirmDays: bigint, invExitDays: bigint, votePrepareDays: bigint, votingDays: bigint, execDaysForPutOpt: bigint, vetoers: [bigint, bigint], class: bigint }
  
    }

  export interface RulesParserInterface extends Interface {
    getFunction(nameOrSignature: "DistrRuleParser" | "firstRefusalRuleParser" | "governanceRuleParser" | "groupUpdateOrderParser" | "linkRuleParser" | "listingRuleParser" | "positionAllocateRuleParser" | "votingRuleParser"): FunctionFragment;

    

    encodeFunctionData(functionFragment: 'DistrRuleParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'firstRefusalRuleParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'governanceRuleParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'groupUpdateOrderParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'linkRuleParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'listingRuleParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'positionAllocateRuleParser', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'votingRuleParser', values: [BytesLike]): string;

    decodeFunctionResult(functionFragment: 'DistrRuleParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'firstRefusalRuleParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'governanceRuleParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'groupUpdateOrderParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'linkRuleParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'listingRuleParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'positionAllocateRuleParser', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'votingRuleParser', data: BytesLike): Result;
  }

  

  export interface RulesParser extends BaseContract {
    
    connect(runner?: ContractRunner | null): RulesParser;
    waitForDeployment(): Promise<this>;

    interface: RulesParserInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    DistrRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.DistrRuleStructOutput],
      'view'
    >
    

    
    firstRefusalRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.FirstRefusalRuleStructOutput],
      'view'
    >
    

    
    governanceRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.GovernanceRuleStructOutput],
      'view'
    >
    

    
    groupUpdateOrderParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.GroupUpdateOrderStructOutput],
      'view'
    >
    

    
    linkRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.LinkRuleStructOutput],
      'view'
    >
    

    
    listingRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.ListingRuleStructOutput],
      'view'
    >
    

    
    positionAllocateRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.PositionAllocateRuleStructOutput],
      'view'
    >
    

    
    votingRuleParser: TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.VotingRuleStructOutput],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'DistrRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.DistrRuleStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'firstRefusalRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.FirstRefusalRuleStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'governanceRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.GovernanceRuleStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'groupUpdateOrderParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.GroupUpdateOrderStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'linkRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.LinkRuleStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'listingRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.ListingRuleStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'positionAllocateRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.PositionAllocateRuleStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'votingRuleParser'): TypedContractMethod<
      [sn: BytesLike, ],
      [RulesParser.VotingRuleStructOutput],
      'view'
    >;

    

    filters: {
      
    };
  }