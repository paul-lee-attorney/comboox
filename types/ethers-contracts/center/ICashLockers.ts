/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../common.js"
  
export declare namespace UsdLockersRepo {
      
    export type HeadStruct = {from: AddressLike, payer: BigNumberish, expireDate: BigNumberish, state: BigNumberish, to: AddressLike, payee: BigNumberish, pickupDate: BigNumberish, flag: boolean, amt: BigNumberish}

    export type HeadStructOutput = [from: string, payer: bigint, expireDate: bigint, state: bigint, to: string, payee: bigint, pickupDate: bigint, flag: boolean, amt: bigint] & {from: string, payer: bigint, expireDate: bigint, state: bigint, to: string, payee: bigint, pickupDate: bigint, flag: boolean, amt: bigint }
  

    export type BodyStruct = {counterLocker: AddressLike, payload: BytesLike}

    export type BodyStructOutput = [counterLocker: string, payload: string] & {counterLocker: string, payload: string }
  

    export type LockerStruct = {head: UsdLockersRepo.HeadStruct, body: UsdLockersRepo.BodyStruct}

    export type LockerStructOutput = [head: UsdLockersRepo.HeadStructOutput, body: UsdLockersRepo.BodyStructOutput] & {head: UsdLockersRepo.HeadStructOutput, body: UsdLockersRepo.BodyStructOutput }
  
    }

export declare namespace ICashLockers {
      
    export type TransferAuthStruct = {from: AddressLike, to: AddressLike, value: BigNumberish, validAfter: BigNumberish, validBefore: BigNumberish, nonce: BytesLike, v: BigNumberish, r: BytesLike, s: BytesLike}

    export type TransferAuthStructOutput = [from: string, to: string, value: bigint, validAfter: bigint, validBefore: bigint, nonce: string, v: bigint, r: string, s: string] & {from: string, to: string, value: bigint, validAfter: bigint, validBefore: bigint, nonce: string, v: bigint, r: string, s: string }
  
    }

  export interface ICashLockersInterface extends Interface {
    getFunction(nameOrSignature: "counterOfLockers" | "custodyOf" | "getHeadOfLocker" | "getLocker" | "getLockersList" | "isLocked" | "lockConsideration" | "lockUsd" | "totalCustody" | "unlockUsd" | "withdrawUsd"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "LockConsideration" | "LockUsd" | "UnlockUsd" | "WithdrawUsd"): EventFragment;

    encodeFunctionData(functionFragment: 'counterOfLockers', values?: undefined): string;
encodeFunctionData(functionFragment: 'custodyOf', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'getHeadOfLocker', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'getLocker', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'getLockersList', values?: undefined): string;
encodeFunctionData(functionFragment: 'isLocked', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'lockConsideration', values: [ICashLockers.TransferAuthStruct, AddressLike, BigNumberish, AddressLike, BytesLike, BytesLike]): string;
encodeFunctionData(functionFragment: 'lockUsd', values: [ICashLockers.TransferAuthStruct, AddressLike, BigNumberish, BytesLike]): string;
encodeFunctionData(functionFragment: 'totalCustody', values?: undefined): string;
encodeFunctionData(functionFragment: 'unlockUsd', values: [BytesLike, string]): string;
encodeFunctionData(functionFragment: 'withdrawUsd', values: [BytesLike]): string;

    decodeFunctionResult(functionFragment: 'counterOfLockers', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'custodyOf', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getHeadOfLocker', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getLocker', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getLockersList', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'isLocked', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'lockConsideration', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'lockUsd', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'totalCustody', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'unlockUsd', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'withdrawUsd', data: BytesLike): Result;
  }

  
    export namespace LockConsiderationEvent {
      export type InputTuple = [from: AddressLike, to: AddressLike, amt: BigNumberish, expireDate: BigNumberish, lock: BytesLike];
      export type OutputTuple = [from: string, to: string, amt: bigint, expireDate: bigint, lock: string];
      export interface OutputObject {from: string, to: string, amt: bigint, expireDate: bigint, lock: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace LockUsdEvent {
      export type InputTuple = [from: AddressLike, to: AddressLike, amt: BigNumberish, expireDate: BigNumberish, lock: BytesLike];
      export type OutputTuple = [from: string, to: string, amt: bigint, expireDate: bigint, lock: string];
      export interface OutputObject {from: string, to: string, amt: bigint, expireDate: bigint, lock: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace UnlockUsdEvent {
      export type InputTuple = [from: AddressLike, to: AddressLike, amt: BigNumberish, lock: BytesLike];
      export type OutputTuple = [from: string, to: string, amt: bigint, lock: string];
      export interface OutputObject {from: string, to: string, amt: bigint, lock: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace WithdrawUsdEvent {
      export type InputTuple = [from: AddressLike, amt: BigNumberish, lock: BytesLike];
      export type OutputTuple = [from: string, amt: bigint, lock: string];
      export interface OutputObject {from: string, amt: bigint, lock: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface ICashLockers extends BaseContract {
    
    connect(runner?: ContractRunner | null): ICashLockers;
    waitForDeployment(): Promise<this>;

    interface: ICashLockersInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    counterOfLockers: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    custodyOf: TypedContractMethod<
      [acct: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    getHeadOfLocker: TypedContractMethod<
      [lock: BytesLike, ],
      [UsdLockersRepo.HeadStructOutput],
      'view'
    >
    

    
    getLocker: TypedContractMethod<
      [lock: BytesLike, ],
      [UsdLockersRepo.LockerStructOutput],
      'view'
    >
    

    
    getLockersList: TypedContractMethod<
      [],
      [string[]],
      'view'
    >
    

    
    isLocked: TypedContractMethod<
      [lock: BytesLike, ],
      [boolean],
      'view'
    >
    

    
    lockConsideration: TypedContractMethod<
      [auth: ICashLockers.TransferAuthStruct, to: AddressLike, expireDate: BigNumberish, counterLocker: AddressLike, payload: BytesLike, hashLock: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    lockUsd: TypedContractMethod<
      [auth: ICashLockers.TransferAuthStruct, to: AddressLike, expireDate: BigNumberish, lock: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    totalCustody: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    unlockUsd: TypedContractMethod<
      [lock: BytesLike, key: string, ],
      [void],
      'nonpayable'
    >
    

    
    withdrawUsd: TypedContractMethod<
      [lock: BytesLike, ],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'counterOfLockers'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'custodyOf'): TypedContractMethod<
      [acct: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getHeadOfLocker'): TypedContractMethod<
      [lock: BytesLike, ],
      [UsdLockersRepo.HeadStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'getLocker'): TypedContractMethod<
      [lock: BytesLike, ],
      [UsdLockersRepo.LockerStructOutput],
      'view'
    >;
getFunction(nameOrSignature: 'getLockersList'): TypedContractMethod<
      [],
      [string[]],
      'view'
    >;
getFunction(nameOrSignature: 'isLocked'): TypedContractMethod<
      [lock: BytesLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'lockConsideration'): TypedContractMethod<
      [auth: ICashLockers.TransferAuthStruct, to: AddressLike, expireDate: BigNumberish, counterLocker: AddressLike, payload: BytesLike, hashLock: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'lockUsd'): TypedContractMethod<
      [auth: ICashLockers.TransferAuthStruct, to: AddressLike, expireDate: BigNumberish, lock: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'totalCustody'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'unlockUsd'): TypedContractMethod<
      [lock: BytesLike, key: string, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'withdrawUsd'): TypedContractMethod<
      [lock: BytesLike, ],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'LockConsideration'): TypedContractEvent<LockConsiderationEvent.InputTuple, LockConsiderationEvent.OutputTuple, LockConsiderationEvent.OutputObject>;
getEvent(key: 'LockUsd'): TypedContractEvent<LockUsdEvent.InputTuple, LockUsdEvent.OutputTuple, LockUsdEvent.OutputObject>;
getEvent(key: 'UnlockUsd'): TypedContractEvent<UnlockUsdEvent.InputTuple, UnlockUsdEvent.OutputTuple, UnlockUsdEvent.OutputObject>;
getEvent(key: 'WithdrawUsd'): TypedContractEvent<WithdrawUsdEvent.InputTuple, WithdrawUsdEvent.OutputTuple, WithdrawUsdEvent.OutputObject>;

    filters: {
      
      'LockConsideration(address,address,uint256,uint256,bytes32)': TypedContractEvent<LockConsiderationEvent.InputTuple, LockConsiderationEvent.OutputTuple, LockConsiderationEvent.OutputObject>;
      LockConsideration: TypedContractEvent<LockConsiderationEvent.InputTuple, LockConsiderationEvent.OutputTuple, LockConsiderationEvent.OutputObject>;
    

      'LockUsd(address,address,uint256,uint256,bytes32)': TypedContractEvent<LockUsdEvent.InputTuple, LockUsdEvent.OutputTuple, LockUsdEvent.OutputObject>;
      LockUsd: TypedContractEvent<LockUsdEvent.InputTuple, LockUsdEvent.OutputTuple, LockUsdEvent.OutputObject>;
    

      'UnlockUsd(address,address,uint256,bytes32)': TypedContractEvent<UnlockUsdEvent.InputTuple, UnlockUsdEvent.OutputTuple, UnlockUsdEvent.OutputObject>;
      UnlockUsd: TypedContractEvent<UnlockUsdEvent.InputTuple, UnlockUsdEvent.OutputTuple, UnlockUsdEvent.OutputObject>;
    

      'WithdrawUsd(address,uint256,bytes32)': TypedContractEvent<WithdrawUsdEvent.InputTuple, WithdrawUsdEvent.OutputTuple, WithdrawUsdEvent.OutputObject>;
      WithdrawUsd: TypedContractEvent<WithdrawUsdEvent.InputTuple, WithdrawUsdEvent.OutputTuple, WithdrawUsdEvent.OutputObject>;
    
    };
  }